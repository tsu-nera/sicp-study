#+title: 第 1 章 手続きによる抽象

* Exercise 1.1
  Below is a sequence of expressions.  What is the
  result printed by the interpreter in response to each expression?
  Assume that the sequence is to be evaluated in the order in which
  it is presented.

#+begin_src emacs-lisp
10					; => 10

(+ 5 3 4)				; => 12

(- 9 1)					; => 8

(/ 6 2) 				; => 3

(+ (* 2 4) (- 4 6))			; => 6

(setq a 3)				; => 3

(setq b (+ a 1))			; => 4

(+ a b (* a b))				; => 19

(= a b)					; => nil

(if (and (> b a) (< b (* a b)))
    b
  a)					; => 4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (t 25))				; => 16

(+ 2 (if (> b a) b a))			; => 6

(* (cond ((> a b) a)
	 ((< a b) b)
	 (t -1))
   (+ a 1))				; =>16
#+end_src

* Exercise 1.2

#+begin_src emacs-lisp
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4.0 5))))) (* 3 (- 6 2) (- 2 7)))
#+end_src

* Exercise 1.3
  3 つの数値を引数として取り, 内 2 つの大きな数値
  の二乗の和を返す手続を定義せよ.

#+begin_src emacs-lisp
(defun ex1-3 (a b c)
  (cond ((and (< a b) (< a c))
	(+ (* b b) (* c c)))
	((and (< b a) (< b c))
	(+ (* a a) (* c c)))
	(t
	 (+ (* a a) (* b b)))))
#+end_src

* Exercise 1.4:
  我々の評価モデルがオペレータが複合式である組み
  合わせを可能にすることを観察せよ. この観察結果を用いて次の
  手続の挙動を説明せよ:
  
#+begin_src emacs-lisp
(defun a-plus-abs-b (a b)
  (if (> b 0)
       (+ a b)
    (- a b)))

(a-plus-abs-b 1 1)
(a-plus-abs-b 1 -1)
#+end_src

* Exercise 1.5:
  Ben Bitdiddle は自分が直面するインタプリタが適用順評価と
  正規順評価のどちらを用いるか決定するテストを開発した.

  まず以下の 2 つの手続を定義する.次に以下の式を評価する.

#+begin_src emacs-lisp
(defun p () p)

(defun test (x y)
  (if (= x 0) 0 y))

(test 0 'p)
#+end_src

Ben は適用順評価を用いるインタプリタではどのような挙動を観察するだろうか? 
Ben は正規順評価を用いるインタプリタではどのような挙動を観察するだろうか? 

あなたの回答を説明せよ. 

(特殊形式の if はインタプリタが適用順評価でも正規順評価でも同じ
挙動を行うと仮定せよ:
述語式が最初に評価され, 
結果が consequent と alternative のどちらを評価するか決定する)

* Exercise 1.6

#+begin_src emacs-lisp
(defun new-if (predicate then-clause else-clause)
  (cond (predicate then-clause)
	(t else-clause)))

(new-if (= 2 3) 0 5)
(new-if (= 1 1) 0 5)

(defun squr-iter (guess x)
  (new-if (good-enough? guess x)
      guess
    (squr-iter (improve guess x)
	       x)))

(defun improve (guess x)
  (average guess (/ x guess)))

(defun average (x y)
  (/ (+ x y) 2))

(defun square (guess)
  (expt guess 2))

(defun good-enough? (guess x)
  (< (abs (- (square guess) x)) 0.001))

(defun my-sqrt (x)
  (squr-iter 1.0 x))
  
(my-sqrt 9)
#+end_src

-> max-lisp-eval-depth
  http://community.schemewiki.org/?sicp-ex-1.6

* Exercise 1.7

(my-sqrt 900000000000000000000000000000)
-> max-lisp-eval-depth

(my-sqrt 0.00000000000000000000000000001)
-> 0.3125 のまま.

#+begin_src emacs-lisp
(defun squr-iter (guess pre-guess x)
  (if (good-enough? guess pre-guess)
      guess
    (squr-iter (improve guess x) guess
	       x)))

(defun improve (guess x)
  (average guess (/ x guess)))

(defun average (x y)
  (/ (+ x y) 2))

(defun square (guess)
  (expt guess 2))

(defun good-enough? (guess pre-guess)
  (< (abs (- guess pre-guess)) 0.001))

(defun my-sqrt (x)
  (squr-iter 1.0 2.0 x))

(my-sqrt 9)

#+end_src

- http://community.schemewiki.org/?sicp-ex-1.7

* Exercise 1.8
  Newton's method for cube roots is based on the
  fact that if y is an approximation to the cube root of x, then a
  better approximation is given by the value
  
  x/y^2 + 2y
  ----------
      3
  
  Use this formula to implement a cube-root procedure analogous to
  the square-root procedure.  (In section *Note 1-3-4:: we will see
  how to implement Newton's method in general as an abstraction of
  these square-root and cube-root procedures.)

#+begin_src emacs-lisp
(defun cube-iter (guess x)
  (if (good-enough? guess x)
      guess
    (cube-iter (improve guess x)
	       x)))

(defun improve (guess x)
  (/ (+ (/ x (expt guess 2)) (* 2 guess)) 3))

(defun good-enough? (guess x)
  (< (abs (- (cube guess) x)) 0.001))

(defun cube (guess)
  (expt guess 3))

(defun my-cube (x)
    (cube-iter 1.0 x))

(my-cube 27)
#+end_src

* 1.9
  lecture と同じなので, 省略.

  Iterative な定義.

 #+begin_src emacs-lisp
;; normal-order evaluation
;; linier iteration
(defun plus (x y)
  (if (= x 0)
      y
    (+ (1- x) (1+ y))))
#+end_src

   Recursive な定義.

#+begin_src emacs-lisp
;; applicative-order evaluation
;; linier recursion
(defun plus (x y)
  (if (= x 0)
      y
    (1+ (+ (1- x) y))))
(plus 4 5)
#+end_src

* 1.10
  The following procedure computes a mathematical
  function called Ackermann's function.

#+begin_src emacs-lisp
(defun A (x y)
  (cond ((= y 0) 0)
	((= x 0) (* 2 y))
	((= y 1) 2)
	(t (A (- x 1)
		 (A x (- y 1))))))
#+end_src

What are the values of the following expressions?

#+begin_src emacs-lisp
(A 1 10)				; => 1024

(A 2 4)					; => 65536

(A 3 3)					; => 65536
#+end_src

Consider the following procedures, where `A' is the procedure

#+begin_src emacs-lisp
(defun k (n) (* 5 n n))
;; 5n^2
(k 2)					; => 20

;; ------------------
(defun f (n) (A 0 n))
;; 2n
(f 1)					; => 2
(f 2)					; => 4
(f 4)					; => 8

;; ------------------
(defun g (n) (A 1 n))
;; 2^n
(g 1)					; => 2
(g 2)					; => 4
(g 3)					; => 8
(g 4)					; => 16

;; ------------------
;; 2^2^2^2^...(n times)
(defun h (n) (A 2 n))
(h 1)					; => 2
(A 2 1)					; => 2

(h 2)					; => 4
(h 3)					; => 16
(h 4)					; => 65536
;; (h 5)				; => error.

#+end_src

Give concise mathematical definitions for the functions computed
by the procedures `f', `g', and `h' for positive integer values of
n.  For example, `(k n)' computes 5n^2.

- http://community.schemewiki.org/?sicp-ex-1.10
