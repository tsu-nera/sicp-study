* Chapter 1::        Building Abstractions with Procedures
** 1.1 手続きによる抽象
  - 複数の単純な考えを合成して 1 つにする.
  - 2 つの考えを同時に見えるように 1 つのもので繋ぐ.
    その実在においてそれらに付随しているほかの考えからそれらを分離する

  言語は以下の仕掛けを有している.

  |                      | procedures     | data      |
  |----------------------+----------------+-----------|
  | primitive element    | +, *, <, =     | 23, 1.738 |
  |----------------------+----------------+-----------|
  | means of combination | () combination |           |
  |                      | if             |           |
  |                      | cond           |           |
  |----------------------+----------------+-----------|
  | means of abstraction | defun          |           |
  
*** primitive expressions 基本式: 
     - which represent the simplest entities the language is concerned with,
     - 言語が関わるもっとも単純なものを表す.

#+begin_src emacs-lisp
1
#+end_src

*** means of combination 組み合わせ法: 
     - by which compound elements are built from simpler ones.
     - より単純なものから合成物をつくる

#+begin_src emacs-lisp
(* 1 1)
#+end_src

*** means of abstraction 抽象化法: 
   - by which compound elements can be named and manipulated as units.
   - 合成物に名をつけ, 単一のもとして扱う.

#+begin_src emacs-lisp
(defun square (x) (* x x))
#+end_src

   これは, 以下の糖衣構文となっている. 
   Lisp インタプリタは実際には以下のように解釈している.

#+begin_src emacs-lisp
(defun square
    (lambda (x) (* x x))

(square (square (square 2)))
#+end_src

  lmabda は procedure を生成する. 

  ポイントは,

  *primitive な値と関数との間に区別がないこと*
   
  抽象化によって, primitive な値を自分で定義できる.

*** Newton 法  
#+begin_src emacs-lisp
(defun squr-iter (guess x)
  (if (good-enough? guess x)
      guess
    (squr-iter (improve guess x)
	       x)))

(defun improve (guess x)
  (average guess (/ x guess)))

(defun average (x y)
  (/ (+ x y) 2))

(defun square (guess)
  (expt guess 2))

(defun good-enough? (guess x)
  (< (abs (- (square guess) x)) 0.001))

(defun my-sqrt (x)
  (squr-iter 1.0 x))
  
(my-sqrt 9)
#+end_src

#+RESULTS:
: 3.00009155413138

*** 1.1.8 ブラックボックス
    means of abstraction は, ブラックボックス.
    利用者は, それがどう実装されているかを知る必要はない.
    つまり,

    *手続きの抽象化 procedure abstruction* 

    と言える.

*** 1.1.9 内部定義とブロック構造
    手続きの仮引数は局所的である.
    関数の定義は局所的でない.

    手続きをブラックボックスにするためには,
    利用者に必要のない関数は隠蔽する必要がある.

    定義の入れ子を *ブロック構造* という.
    ブロック構造の中で定義された関数は局所的である.

**** ブロック構造による newton 法の書き直し.
     Emacs Lisp は, ダイナミックスコープを採用している.
     これでは関数定義がブロックの外でも呼び出せてしまう..

    ;;; -*- lexical-binding: t -*- をファイルの先頭に追記する

 #+begin_src emacs-lisp
;;; -*- coding: utf-8; lexical-binding: t -*-
(defun my-sqrt (x)
  (defun squr-iter (guess x)
    (if (good-enough? guess x)
	guess
      (squr-iter (improve guess x)
		 x)))
  (defun improve (guess x)
    (average guess (/ x guess)))
  (defun average (x y)
    (/ (+ x y) 2))
  (defun square (guess)
    (expt guess 2))
  (defun good-enough? (guess x)
    (< (abs (- (square guess) x)) 0.001))
  (squr-iter 1.0 x))
(my-sqrt 9)
#+end_src

** 1.2 手続きとその生成するプロセス 
   Procedures and the Processes They Generate.

   Lecture 1B | MIT 6.001 Structure and Interpretation, 1986:
   -  http://youtu.be/dlbMuv-jix8

*** Peano Arithmetic
    Iterative な定義.

 #+begin_src emacs-lisp
;; normal-order evaluation
;; linear iteration
(defun plus (x y)	      
  (if (= x 0)
      y
    (+ (1- x) (1+ y))))

(plus 4 3)
#+end_src

   Recursive な定義.

#+begin_src emacs-lisp
;; applicative-order evaluation
;; linier recursion
(defun plus (x y)
  (if (= x 0)
      y
    (1+ (+ (1- x) y))))
(plus 4 5)
#+end_src

    exercise 1.9 とかぶる.

*** 1.2.2
    - [[info:sicp.info#1-2-2]]

    再帰による fibonacci.基本的だが, 冗長過ぎる.
  
  #+begin_src emacs-lisp
(defun fib (n)
  (cond ((= n 0) 0)
	((= n 1) 1)
	(t (+ (fib (- n 1))
	      (fib (- n 2))))))

(fib 4)					; => 3
(fib 5)					; => 5
(fib 6)					; => 8
(fib 7)					; => 13
  #+end_src

    反復による fibonacci. 状態変数として a, b, count を導入している.
    - [[info:sicp.info#1-2-2]]

  #+begin_src emacs-lisp
(defun fib (n)
  (fib-iter 1 0 n))

(defun fib-iter (a b count)
  (if (= count 0)
      b
    (fib-iter (+ a b) a (- count 1))))

(fib 6)					; => 8
(fib 7)					; => 13
(fib 8)					; => 21
  #+end_src

**** ex
     - If a is exactly 0, we should count that as 1 way to make change.
     - If a is less than 0, we should count that as 0 ways to make change.
     - If n is 0, we should count that as 0 ways to make change.

     We can easily translate this description into a recursive procedure:

 #+begin_src emacs-lisp
(defun count-change (amount)
  (cc amount 2))

(defun cc (amount kinds-of-coins)
  (cond ((= amount 0) 1)
	((or (< amount 0) (= kinds-of-coins 0)) 0)
	(t (+ (cc amount
		  (- kinds-of-coins 1))
	      (cc (- amount
		     (first-denomination kinds-of-coins))
		  kinds-of-coins)))))

(defun first-denomination (kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
	((= kinds-of-coins 2) 5)))

(count-change 10)
 #+end_src

 #+begin_src emacs-lisp
(cc 10 2)
(+ (cc 10 1) (cc (- 10 (first-denomination 2)) 2))
(+ (cc 10 1) (cc (- 10 5) 2))
(+ (cc 10 1) (cc 5 2))
(+ (+ (cc 10 0) (cc 9 1)) (cc 5 2))
(+ (+ 0 (cc 9 1)) (cc 5 2))
(+ 1 (cc 5 2))
(+ 1 (+ (cc 5 1) (cc 1 2)))
(+ 1 (+ 1 (cc 1 2)))
(+ 1 (+ 1 (+ (cc 1 1) (cc -1 1))))
(+ 1 (+ 1 (+ 1 0)))
3
 #+end_src

 #+begin_src emacs-lisp
(defun count-change (amount)
  (cc amount 5))

(defun cc (amount kinds-of-coins)
  (cond ((= amount 0) 1)
	((or (< amount 0) (= kinds-of-coins 0)) 0)
	(t (+ (cc amount
		  (- kinds-of-coins 1))
	      (cc (- amount
		     (first-denomination kinds-of-coins))
		  kinds-of-coins)))))

(defun first-denomination (kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
	((= kinds-of-coins 2) 5)
	((= kinds-of-coins 3) 10)
	((= kinds-of-coins 4) 25)
	((= kinds-of-coins 5) 50)))

(count-change 100)			; => 292
 #+end_src

** 1.3 高階手続きによる抽象
   https://www.youtube.com/watch?v=erHp3r6PbJk&list=PL8FE88AA54363BC46&index=3

* Chapter 2::        Building Abstractions with Data
* Chapter 3::        Modularity, Objects, and State
* Chapter 4::        Metalinguistic Abstraction
* Chapter 5::        Computing with Register Machines

